package tys.frontier.code.typeInference;

import com.google.common.collect.ListMultimap;
import com.google.common.collect.MultimapBuilder;
import tys.frontier.code.TypeInstantiation;
import tys.frontier.code.expression.cast.ImplicitTypeCast;
import tys.frontier.code.type.FType;
import tys.frontier.code.type.FTypeVariable;
import tys.frontier.parser.syntaxErrors.IncompatibleTypes;
import tys.frontier.parser.syntaxErrors.UnfulfillableConstraints;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Multimaps.asMap;
import static tys.frontier.util.Utils.map;

public class Constraints {

    private ListMultimap<FTypeVariable, ImplicitCastable> implicitCastables = MultimapBuilder.hashKeys().arrayListValues().build();

    public List<ImplicitCastable> get(FTypeVariable key) {
        return implicitCastables.get(key);
    }

    public void add(FTypeVariable key, ImplicitCastable castable) {
        implicitCastables.put(key, castable);
    }

    public void addAll(FTypeVariable key, Iterable<ImplicitCastable> castables) {
        implicitCastables.putAll(key, castables);
    }

    public Iterable<ImplicitCastable> values() {
        return implicitCastables.values();
    }

    public void checkAll() throws UnfulfillableConstraints {
        for (Map.Entry<FTypeVariable, ImplicitCastable> entry : implicitCastables.entries())
            if (!entry.getKey().satisfies(entry.getValue()))
                throw new UnfulfillableConstraints(values());
    }

    public void checkAllWithUntyped(List<FTypeVariable> untyped, Constraints constraintsForUntyped) throws UnfulfillableConstraints {
        for (Map.Entry<FTypeVariable, List<ImplicitCastable>> entry : asMap(implicitCastables).entrySet()) {
            if (untyped.contains(entry.getKey())) {
                constraintsForUntyped.addAll(entry.getKey(), entry.getValue());
            } else {
                for (ImplicitCastable implicitCastable : entry.getValue()) {
                    FType target = implicitCastable.getTarget();
                    if (target instanceof FTypeVariable && untyped.contains((FTypeVariable) target))
                        continue;
                    if (entry.getKey().satisfies(implicitCastable))
                        continue;
                    throw new UnfulfillableConstraints(values());
                }
            }
        }
    }

    // If any constraints for the variables in untyped are generated by resolving, they will be added to 'this'
    public TypeInstantiation resolveAllWithUntyped(Collection<FTypeVariable> toResolves, List<FTypeVariable> untyped) throws UnfulfillableConstraints {
        assert implicitCastables.keySet().containsAll(toResolves);
        Map<FTypeVariable, FType> resolveMap = new HashMap<>();

        for (FTypeVariable toResolve : toResolves) {
            List<ImplicitCastable> constraints = get(toResolve);
            assert constraints.stream().noneMatch(c -> c.getTarget() instanceof FTypeVariable && toResolves.contains((FTypeVariable) c.getTarget()));
            resolveMap.put(toResolve, resolve(toResolve, constraints, c -> c.checkAllWithUntyped(untyped, this)));
        }

        return TypeInstantiation.create(resolveMap);
    }


    // TODO less overloads of resolve, there should be a simper way

    public static FType resolve(FTypeVariable var, List<ImplicitCastable> constraints) throws UnfulfillableConstraints {
        return resolve(var, constraints, Constraints::checkAll);
    }

    public FType resolve(FTypeVariable key, TypeInstantiation typeInstantiation) throws UnfulfillableConstraints {
        return resolve(key, get(key), typeInstantiation);
    }

    public static FType resolve(FTypeVariable var, List<ImplicitCastable> constraints, TypeInstantiation typeInstantiation) throws UnfulfillableConstraints {
        return resolve(var, map(constraints, c -> {
            FType target = typeInstantiation.getType(c.getTarget());
            return target == c.getTarget() ? c : new ImplicitCastable(c, target, c.getVariance());
        }));
    }

    @FunctionalInterface
    public interface ContraintChecker { void check(Constraints constraints) throws UnfulfillableConstraints; }
    private static FType resolve(FTypeVariable var, List<ImplicitCastable> constraints, ContraintChecker contraintChecker) throws UnfulfillableConstraints {
        // just try every candidate
        candidates: for (ImplicitCastable constraint : constraints) {
            FType candidate = constraint.getTarget();
            if (candidate == var)
                continue;

            // TODO check if candidate fullfills all constraints on var! (this is kind of important...)

            // see if we can cast the candidate from all other
            Constraints newConstraints = new Constraints();
            for (ImplicitCastable other : constraints) {
                FType target = other.getTarget();
                if (candidate == target || target == var)
                    continue;
                try {
                    ImplicitTypeCast.create(candidate, target, constraint.getVariance(), newConstraints);
                } catch (IncompatibleTypes e) {
                    continue candidates;
                }
            }
            try {
                contraintChecker.check(newConstraints);
                return candidate;
            } catch (UnfulfillableConstraints e) {
                // continue candidates
            }
        }

        // no candidate worked, can't resolve, throw exception
        throw new UnfulfillableConstraints(constraints);
    }



}
