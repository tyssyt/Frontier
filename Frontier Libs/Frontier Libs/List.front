export class List<T>:
    for: operator[]**(List<T>, int32), size**(List<T>);

    elements: [T];
    export size: int32 = 0; //TODO export getter, private setter

    export static create(startSize: int32 = 5) -> List<T> {
        res:List<T> = List<T>(elements = [T, startSize]);
        return res;
    }

    export add(e: T) {
        if size >= elements.size {
            expand();
        }
        elements[size] = e;
        size = size+1;
    }

    export add(e: T, pos: int32) {
        if size >= elements.size {
            expand();
        }
        rShift(pos);
        elements[pos] = e;
        size = size+1;
    }

    export addAll(elements: [T]) { //TODO iterable interface
        //TODO one expand check at the beginning, that add without expand check
        for e : elements {
            add(e);
        }
    }

    export operator [] (pos: int32) <- e: T {
        elements[pos] = e;
    }

    export operator [] (i: int32) -> T {
        return elements[i];
    }

    export clear() {
        size=0;
    }

    export remove() -> T {
        size = size-1;
        return elements[size];
    }

    export removeUnordered(pos: int32) -> T {
        res := elements[pos];
        size = size-1;
        elements[pos] = elements[size];
        return res;
    }

    export removeOrdered(pos: int32) -> T {
        res := elements[pos];
        lShift(pos);
        size = size-1;
        return res;
    }

    export trim() -> [T] {
        res := [T, size];
        elements.copy(res, length=size);
        return res;
    }

    private expand() {
        newSize:int32 = 2*elements.size;
        if newSize < 10 {
            newSize = 10;
        }

        newElements := [T, newSize];
        elements.copy(newElements);
        elements = newElements;
    }

    private rShift(start: int32) { //TODO replace by arrayCopy... once we have that
        i := size;
        while i>start {
            elements[i] = elements[i-1];
        size = size-1;
        }
    }

    private lShift(end: int32) { //TODO replace by arrayCopy... once we have that
        i := end;
        while i<size-1 {
            elements[i] = elements[i+1];
            i = i+1;
        }
    }